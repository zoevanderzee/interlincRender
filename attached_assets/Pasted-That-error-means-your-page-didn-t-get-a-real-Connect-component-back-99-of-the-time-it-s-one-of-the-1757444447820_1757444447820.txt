That error means your page didn’t get a real Connect component back. 99% of the time it’s one of these:
The server returned the session ID (e.g. ass_… / accs_…) instead of the Account Session client secret (seti_…).
The page is importing the wrong SDK (@stripe/stripe-js) or mixing both SDKs.
loadConnectAndInitialize didn’t initialize (bad PK / wrong secret / mode mismatch), so connect.create(...) returned a non-mountable object.
Here’s a drop-in, fool-proof fix for your agent. Paste this—verbatim—and have them replace the files. It hard-fails with clear messages if anything is off.
1) Server (must return a seti_ client secret)
// server/connect-routes.js
import express from "express";
import Stripe from "stripe";

const router = express.Router();
const sk = process.env.STRIPE_SECRET_KEY;
if (!sk) throw new Error("Missing STRIPE_SECRET_KEY");
const stripe = new Stripe(sk, { apiVersion: "2024-06-20" });

router.post("/connect/create-account-session", async (req, res) => {
  try {
    let { accountId = null, country = "GB", publishableKey } = req.body || {};

    // Optional: ensure client PK mode matches server SK mode
    const pkMode = publishableKey?.startsWith("pk_live_") ? "live"
                : publishableKey?.startsWith("pk_test_") ? "test" : "unknown";
    const skMode = sk.startsWith("sk_live_") ? "live"
                : sk.startsWith("sk_test_") ? "test" : "unknown";
    if (publishableKey && pkMode !== skMode) {
      return res.status(400).json({ error: `Key mode mismatch (client=${pkMode}, server=${skMode})` });
    }

    if (!accountId) {
      const acct = await stripe.accounts.create({
        type: "custom",
        country,
        capabilities: { card_payments: { requested: true }, transfers: { requested: true } },
      });
      accountId = acct.id;
    }

    const session = await stripe.accountSessions.create({
      account: accountId,
      components: { account_onboarding: { enabled: true } },
    });

    const secret = session.client_secret; // MUST be the client secret (seti_...), not session ID
    if (typeof secret !== "string" || !/^seti_/.test(secret)) {
      console.error("[connect] WRONG SECRET RETURNED:", { got: secret?.slice?.(0, 12) });
      return res.status(500).json({ error: "Server did not produce an Account Session client_secret (seti_…)" });
    }

    res.json({ accountId, client_secret: secret });
  } catch (e) {
    console.error("[connect] ERROR", e);
    res.status(500).json({ error: e?.message || "Unknown error" });
  }
});

export default router;
Wire it:
// server/index.js
import express from "express";
import connectRoutes from "./connect-routes.js";
const app = express();
app.use(express.json());
app.use("/api", connectRoutes);
app.listen(process.env.PORT || 3000, () => console.log("Server :3000"));
One-shot check (must show seti_):
curl -s -X POST http://localhost:3000/api/connect/create-account-session \
  -H "Content-Type: application/json" \
  -d '{"accountId":null,"country":"GB"}'
# Expect: {"accountId":"acct_...","client_secret":"seti_..."}
2) Client (React) — assert PK + seti_ and use the right SDK
// client/src/pages/ConnectOnboarding.tsx
import { useEffect, useRef } from "react";
import { loadConnectAndInitialize } from "@stripe/connect-js"; // ✅ correct SDK

const PK = (import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY || "").trim();

function assertPattern(name: string, val: any, re: RegExp) {
  if (typeof val !== "string") throw new Error(`${name} not a string`);
  if (!re.test(val)) throw new Error(`${name} invalid: ${String(val).slice(0,24)}…`);
}

export default function ConnectOnboarding() {
  const started = useRef(false);
  const containerRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    if (started.current) return;
    started.current = true;

    (async () => {
      // 1) Validate PK
      assertPattern("VITE_STRIPE_PUBLISHABLE_KEY", PK, /^pk_(test|live)_[A-Za-z0-9]+/);

      // 2) Fetch Account Session client_secret
      const r = await fetch("/api/connect/create-account-session", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ accountId: null, country: "GB", publishableKey: PK }),
      });
      if (!r.ok) throw new Error(`API ${r.status}: ${await r.text()}`);
      const { accountId, client_secret } = await r.json();

      // 3) Validate response shapes (this prevents the “wrong SDK/init” symptom)
      assertPattern("accountId", accountId, /^acct_[A-Za-z0-9]+/);
      assertPattern("client_secret", client_secret, /^seti_[A-Za-z0-9_]+/);

      // 4) Initialize Connect
      const connect = await loadConnectAndInitialize({
        publishableKey: PK,
        fetchClientSecret: async () => client_secret,
      });
      if (!connect || typeof connect.create !== "function") {
        throw new Error("Connect failed to initialize (check SDK import and PK/secret mode).");
      }

      // 5) Create component
      const comp = connect.create("account-onboarding"); // ✅ correct component id
      if (!comp || typeof (comp as any).mount !== "function") {
        console.error("component object:", comp);
        throw new Error("Connect component not mountable (wrong SDK/import or bad init).");
      }

      // 6) Mount into a real, visible node (not a selector string)
      const el = containerRef.current;
      if (!el) throw new Error("Missing container node");
      const rect = el.getBoundingClientRect();
      if (!rect.width || !rect.height) {
        // Make sure the container isn’t collapsed
        el.style.minHeight = "520px";
        el.style.display = "block";
        el.style.width = "100%";
      }

      comp.on?.("ready", () => console.log("[connect] ready (embedded) for", accountId));
      comp.mount(el);
    })().catch((e) => {
      console.error("[embedded connect failed]", e);
      alert(String(e?.message || e));
    });
  }, []);

  return (
    <div style={{ padding: 24, maxWidth: 720, margin: "0 auto" }}>
      <h1>Embedded Connect Onboarding</h1>
      <div
        id="onboarding-container"
        ref={containerRef}
        style={{ minHeight: 520, width: "100%", border: "1px solid #e5e7eb", background: "#fafafa" }}
      />
    </div>
  );
}
Absolutely do not import @stripe/stripe-js on this page, and do not call accountLinks.create anywhere in this flow.
3) If you STILL see “not mountable”, run these two console probes
On /connect-onboarding, in the browser devtools console:
// 1) Prove the right SDK is on the page
import("@stripe/connect-js").then(m => console.log("connect-js loaded:", typeof m.loadConnectAndInitialize));
// -> should log: "function"

// 2) Prove the server returned a real client secret
fetch("/api/connect/create-account-session",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({accountId:null,country:"GB"})})
  .then(r=>r.json()).then(j=>console.log(j.accountId, j.client_secret && j.client_secret.slice(0,6)))
// -> should log: "acct_..." and "seti_..."
If #1 isn’t “function”, you’re importing the wrong SDK.
If #2 isn’t seti_, your server returned the wrong field—fix the server to return session.client_secret.
Why this fixes your exact error
The seti_ check guarantees you’re feeding Connect.js the correct secret. Passing a session ID (ass_…, accs_…) or anything else makes connect.create(...) produce a non-mountable object.
Importing only @stripe/connect-js ensures you get the Connect component implementation (the mount method exists).
Mounting into a real node avoids selector quirks and silent no-ops.
The mode guard prevents pk/sk test/live mixups that break initialization.
Follow this verbatim and that “not mountable” error will stop.
