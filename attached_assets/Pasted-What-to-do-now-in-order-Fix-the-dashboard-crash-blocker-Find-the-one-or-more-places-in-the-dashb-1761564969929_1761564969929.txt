What to do now (in order)
Fix the dashboard crash (blocker)
Find the one or more places in the dashboard endpoint that reference a bare user instead of the request-scoped user.
Rule: all request handlers must derive identity from the same source (auth middleware → req.user), never from globals or ad-hoc variables.
If the handler needs the full profile, fetch it once (storage/service call) using the ID from req.user, and pass that object down through the handler scope.
Enforce Single Source of Truth (SSOT) for profile/org data
Reads: every endpoint and component must resolve display name, title, and business name from canonical tables only (users, organizations, org_members). No fallbacks to duplicated columns.
Writes: Settings endpoints write only to SSOT. Stripe is updated asynchronously afterwards.
Add cache invalidation after Settings updates
After successful profile/org update:
Invalidate the auth/user cache (e.g., /api/me).
Invalidate any dashboards or list queries that display those fields (e.g., /api/dashboard, work-request lists, task/project lists).
Client: on save, optimistically update local user/org state, then trigger refetch for the invalidated keys.
Event hook for real-time refresh (optional but recommended)
Emit lightweight events on changes: user.updated, organization.updated, org_member.updated with {id, changed_fields}.
Clients that subscribe can refetch or patch local caches, giving instant cross-tab updates.
Stripe sync (asynchronous, idempotent)
After DB commit, enqueue a job:
Business (payer): update Stripe Customer name/email/address.
Contractor (merchant): if you manage Custom accounts, mirror merchant-facing fields; for Express, deep-link the user to update branding in Stripe.
Retries with backoff; no UI blocking.
Guardrails (do not violate)
Do not touch the Direct Payment flow.
Do not create or allow Connect accounts for business users.
Do not duplicate profile or organization names into domain tables (work_requests, projects, messages). If a legacy column still exists, treat it as deprecated and unused for display.
Do not update Stripe before updating your DB. DB is the SSOT; Stripe sync is eventual.
Do not cache user/org data inside component local state beyond the standard query cache. Always re-read via the cache after invalidation.
Specific places to check (common culprits)
Server
Dashboard handler: every usage of user data must come from a single request-scoped variable populated from req.user.id.
Any helper that “memoizes” the user/company across requests—remove or scope it per request.
Settings handlers: ensure they return the freshly updated record (not a stale pre-update read).
Client
Header/Sidebar: bind to the same user/org query the Settings page updates; no shadow copies in component state.
Work Request cards, Task/Project headers, Payment dialogs: names/titles must render from the canonical queries, not props passed long ago.
After Settings save: invalidate /api/me and /api/dashboard (and any list using org/user display fields).
Quick QA script (10 minutes)
Fix verification (crash)
Hit /api/dashboard with a valid session; it must return 200 and include the current user/org names.
Profile update propagation
In Settings, change user display name and job title.
Expect: Header, Sidebar, Dashboard greeting, Work Request cards, and Payment dialogs all show the new name/title after auto-refetch (or on soft refresh).
Organization update propagation
Change organization display name and logo.
Expect: Business name updates in contractor views (work requests), project/task lists, and dashboard tiles. No legacy name appears anywhere.
No duplicates
Inspect network: no endpoint returns a business_name sourced from domain tables; all displays originate from /api/me and /api/organizations/:id (or consolidated dashboard data that itself reads from SSOT).
Stripe sync (eventual)
After org name change, the Stripe Customer for that business shows the new name within the job’s retry window. Payments continue unaffected.
Success criteria
Dashboard no longer throws “ReferenceError: user is not defined.”
Any Settings change reflects across all relevant screens within one refetch cycle.
No stale or mismatched names/titles anywhere.
Direct payments remain untouched and functional.
Stripe customer/connected-account data stays in sync eventually, without blocking UI.