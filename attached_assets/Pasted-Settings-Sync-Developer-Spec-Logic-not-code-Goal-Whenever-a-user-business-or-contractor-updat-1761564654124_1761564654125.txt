Settings Sync — Developer Spec (Logic, not code)
Goal
Whenever a user (business or contractor) updates Settings, the change becomes the single source of truth and is reflected everywhere that value is displayed — immediately and consistently — without duplicating data.
Canonical Data Model (SSOT)
users
id, first_name, last_name, display_name
email, phone
job_title (person-in-charge title)
avatar_url
role (business | contractor | admin)
Stripe: stripe_customer_id (business), stripe_account_id (contractor), charges_enabled, details_submitted
Timestamps
organizations
id, display_name (business name shown in-app)
legal_name (for contracts/invoices)
logo_url
billing_address, tax_id
Timestamps
org_members
org_id, user_id
role_in_org (owner | admin | member)
Optional: title_in_org (if different from user.job_title)
Timestamps
Rule: UI reads these tables directly (or from read models fed by them). Avoid storing copies (e.g., work_requests.business_name) except for legal “snapshots”.
Settings Endpoints (behavioral contract)
GET /api/me → returns canonical user record + active org membership summary.
GET /api/organizations/:orgId → returns canonical organization record.
PUT /api/me
Accepts: display_name, first_name, last_name, job_title, avatar_url, non-sensitive profile fields.
Writes to users.
Emits user.updated.
Returns fresh canonical user.
PUT /api/organizations/:orgId
Accepts: display_name, logo_url, billing fields.
Writes to organizations.
Emits organization.updated.
Returns fresh canonical org.
PUT /api/org-members/:orgId/:userId (optional)
Accepts: role_in_org, title_in_org.
Writes to org_members.
Emits org_member.updated.
Returns fresh membership.
Permissions:
Business org settings: org owner or admin.
User profile: the user themselves (or admin).
Org member roles: org owner or admin.
Validation:
display_name length/charset, uniqueness for org slug if used.
job_title max length.
logo_url/avatar_url must be https.
Tax/billing fields format.
Read Rules (everywhere in app)
When rendering:
Business name → organizations.display_name via org_id.
Person-in-charge title → org_members.role_in_org or users.job_title (choose one canonical source and apply consistently).
User name/avatar → users.display_name or first/last_name + avatar_url.
Prohibited:
Writing or reading business_name, owner_name, etc., from domain tables like work_requests, projects, messages, except where snapshotting is legally required.
Snapshot Policy (immutable)
Only for legal artifacts (invoices, signed contracts, exportable receipts):
Store snapshot fields at creation time: snapshot_business_name, snapshot_legal_name, snapshot_business_address, snapshot_signer_name, etc.
Never mutate snapshot fields after issue/signing.
UI “live views” never use snapshot fields.
Eventing and Real-Time
On successful PUT:
Emit events: user.updated, organization.updated, org_member.updated with minimal payload {id, changed_fields}.
Clients:
Optimistically update local state with API response.
Subscribe via WebSocket/SSE; on matching event, refetch or patch local cache.
Server-side caches / read models:
Invalidate keys referencing the changed user_id/org_id.
Refresh materialized views that denormalize names/logos for lists (if used).
Caching and Read Models
Short TTL caches (e.g., 60–120s) for heavy list endpoints.
Event-driven invalidation for precision:
On organization.updated: invalidate work_requests:list:*:org:{org_id}, projects:list:*:org:{org_id}, search indices for org.
On user.updated: invalidate user:{user_id}, messages:participants:*, search indices for user.
If using materialized views:
Provide a targeted refresh routine keyed by org_id / user_id.
External Sync (Stripe, CRM)
When organizations.display_name or legal_name changes and the user is a payer:
Queue an async job to update the Stripe Customer name/email for the business.
When users.display_name changes:
Optionally sync to external integrations (e.g., email, CRM).
All external syncs must be idempotent and retried on failure.
Audit Trail
Write to audit_log on every settings update:
actor_user_id, target_type (user|organization|org_member), target_id, changed_fields, before, after, timestamp.
UI Contract (predictable updates)
Settings forms submit to the endpoints above.
On success, replace global app state (e.g., currentUser, currentOrganization) with returned payloads.
All components that display these fields bind to global state or query the GET endpoints; no component keeps its own copy beyond view state.
QA Checklist (must pass)
Update organization display_name:
Appears updated in: work requests (business name), project headers, contractor’s inbox, payment dialogs, notifications.
Snapshot invoices/contracts remain unchanged.
Update user job_title / display_name:
Appears updated in: messages, task assignments, headers, request cards.
Multi-tab test:
Change Settings in Tab A; Tab B updates within seconds (event-driven) or on soft refresh.
Legacy fields:
Verify no screen reads from deprecated business_name columns.
Permissions:
Non-admin business user cannot change org-wide fields.
User can change own profile fields.
Stripe sync:
Changing org name triggers a queued sync; Stripe Customer reflects the new name.
Audit:
Audit log entries exist with before/after diffs.
Migration Steps (safe rollout)
Inventory duplicated fields across domain tables.
Add missing canonical fields to users/organizations if needed.
Backfill canonical from the cleanest source.
Switch all reads to canonical (feature-flagged).
Remove writes to duplicated fields.
Keep duplicates read-only for one release; then drop them.
Success Criteria
Any change in Settings is immediately reflected across all live views that reference those values.
Only legal artifacts preserve historical snapshots.
No inconsistencies between pages/components after a single source is updated.
External systems (Stripe Customer) remain in sync asynchronously.